#!/usr/bin/env bash

MAXMEM=4G

# maximal time for kinetics computation
MAXTIME=100000000000; # maximal time (step) to compute

# exit function
die() { echo -e "$*" 1>&2 ; exit 1; }

# check RNA sequence argument
[[ ($# -eq 1 || ($# -eq 2 && $2 =~ ^[0-9]+$ )) && $1 =~ ^[ACGU]+$ ]] || die "\n usage : gcgRNAkinetics.sh <RNA sequence> <MAXTIME=$MAXTIME>";
RNA=$1
# (optional) check maximal time for kinetics computation 
[[ $# -eq 2 ]] && MAXTIME=$2

# whether or not R is available for plotting
Ravailable=1;

# ensure required binaries are in PATH
[[ $(type -P "RNAsubopt") ]] || die "\nERROR : RNAsubopt not in PATH\n";
[[ $(type -P "barriers") ]] || die "\nERROR : barriers not in PATH\n";
[[ $(type -P "treekin") ]] || die "\nERROR : treekin not in PATH\n";
[[ $(type -P "genCG.pl") ]] || die "\nERROR : genCG.pl not in PATH or not executable\n";
if [ ! $(type -P "R") ]; then
	echo -e "\nWARNING : R not in PATH => skipping figure generation\n"; 
	Ravailable=0;
fi

##############  LEVEL 0 ENUMERATION  #################

if [ ! -f $RNA.RNAsubopt.zip ]; then

# enumerate (and sort) all secondary structures (first by energy using structure string for tie breaking)
echo $RNA | RNAsubopt --deltaEnergy=99999 | sort -k 2,2n -k 1,1dr -S $MAXMEM | zip $RNA.RNAsubopt.zip -;

fi

##############  LEVEL 1 COARSE GRAINING  #################

if [ ! -f $RNA.barriers.out ]; then

# run barriers to compute coarse graining level 1
unzip -p $RNA.RNAsubopt.zip | barriers --rates -G RNA -M noShift --bsize --max=999999 --minh=0 > $RNA.barriers.out;
# store rate matrix generated by barriers
mv rates.out $RNA.barriers.rates;
# cleanup obsolete barriers files
rm -f rates.bin tree.ps treeR.ps;

fi

##############  LEVEL >1 COARSE GRAINING  #################

if [ ! -f $RNA.genCG.out ]; then

(
# get micro-state landscape size
printf "#states level 0 = "; unzip -p $RNA.RNAsubopt.zip | grep -c -v $RNA;
# compute generalized coarse grainings
perl genCG.pl $RNA.barriers.out $RNA.barriers.rates
) > $RNA.genCG.out

fi

################  PLOTTING  ######################


# define variables for the following shell function
FILE="undef"; # base file name without extension (.barriers .rates)
OCID=0; # funnel of open chain state to be taken from according barriers output file
LVL=0; # the coarse graining level
# shell function (tested in bash) to compute one plot via treekin 
function runTreekin {
 # output file prefix 
 OUTFILE=$FILE.treekin.p0-$OCID.t8-$MAXTIME
# check if output file exists already (do not replace)
if [ ! -f $OUTFILE.out ]; then
 # ensure file naming for treekin call
 ln -s $FILE.rates rates.out;
  # call treekin
 treekin -m I --p0 $OCID=1  --t8=$MAXTIME < $FILE.barriers > $OUTFILE.out; 
 # cleanup temporary files
 rm -f rates.out;
 # generate output figure in pdf format using R
fi # treekin output exists
if [ $Ravailable == "1" ]; then
 R --vanilla --silent -e "k <- read.table(\"$OUTFILE.out\", header=F, sep=\"\");pdf(\"$OUTFILE.pdf\");matplot(k[,1], k[,2:ncol(k)], main=\"level = $LVL, p0 = $OCID\", xlab=\"time (arbitrary units)\", ylab=\"state probability\", ylim=c(0,1), log=\"x\", type=\"l\");dev.off(); q();"
fi # R available
}


# handle level 1
ln -s -f $RNA.barriers.out $RNA.barriers.out.1.barriers
ln -s -f $RNA.barriers.rates $RNA.barriers.out.1.rates
FILE=$RNA.barriers.out.1
# get open chain ID
OCID=`grep -P "^\\s*\\d+\\s+[\\.]+\\s+0" $RNA.barriers.out | awk 'NR==1 {print $1}'`
runTreekin

# get maximal level
MAXLVL=`ls $RNA.*.gradient | awk -F "." '{print $4}' | tail -n 1`
# reduce by one (last level has only one state)
MAXLVL=$((MAXLVL-1))

# iterate over each level
for LVL in `seq 2 $MAXLVL`; do
	# set file
	FILE=$RNA.barriers.out.$LVL
	# get current OCID via gradient mapping from last level
	LASTOCID=$((OCID+1))
	OCID=`head -n $LASTOCID $FILE.gradient | tail -n 1 | awk '{print $11}'`
	# run treekin
	runTreekin
done # iterate all LVL 

